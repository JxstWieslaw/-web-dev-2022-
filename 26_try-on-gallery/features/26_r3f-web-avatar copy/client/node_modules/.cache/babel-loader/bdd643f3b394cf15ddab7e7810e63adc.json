{"ast":null,"code":"import { EventDispatcher } from '../core/EventDispatcher.js';\nimport { MirroredRepeatWrapping, ClampToEdgeWrapping, RepeatWrapping, LinearEncoding, UnsignedByteType, RGBAFormat, LinearMipmapLinearFilter, LinearFilter, UVMapping } from '../constants.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Source } from './Source.js';\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n  constructor() {\n    let image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Texture.DEFAULT_IMAGE;\n    let mapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Texture.DEFAULT_MAPPING;\n    let wrapS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ClampToEdgeWrapping;\n    let wrapT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ClampToEdgeWrapping;\n    let magFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearFilter;\n    let minFilter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : LinearMipmapLinearFilter;\n    let format = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : RGBAFormat;\n    let type = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : UnsignedByteType;\n    let anisotropy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;\n    let encoding = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : LinearEncoding;\n    super();\n    Object.defineProperty(this, 'id', {\n      value: textureId++\n    });\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.source = new Source(image);\n    this.mipmaps = [];\n    this.mapping = mapping;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n    this.anisotropy = anisotropy;\n    this.format = format;\n    this.internalFormat = null;\n    this.type = type;\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n    //\n    // Also changing the encoding after already used by a Material will not automatically make the Material\n    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n    this.encoding = encoding;\n    this.userData = {};\n    this.version = 0;\n    this.onUpdate = null;\n    this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\n    this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n  }\n\n  get image() {\n    return this.source.data;\n  }\n\n  set image(value) {\n    this.source.data = value;\n  }\n\n  updateMatrix() {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.name = source.name;\n    this.source = source.source;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    this.needsUpdate = true;\n    return this;\n  }\n\n  toJSON(meta) {\n    const isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n\n    const output = {\n      metadata: {\n        version: 4.5,\n        type: 'Texture',\n        generator: 'Texture.toJSON'\n      },\n      uuid: this.uuid,\n      name: this.name,\n      image: this.source.toJSON(meta).uuid,\n      mapping: this.mapping,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      type: this.type,\n      encoding: this.encoding,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n    if (JSON.stringify(this.userData) !== '{}') output.userData = this.userData;\n\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n\n    return output;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  transformUv(uv) {\n    if (this.mapping !== UVMapping) return uv;\n    uv.applyMatrix3(this.matrix);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n\n    return uv;\n  }\n\n  set needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n      this.source.needsUpdate = true;\n    }\n  }\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.prototype.isTexture = true;\nexport { Texture };","map":{"version":3,"sources":["C:/Users/pc/Documents/Repositories/web-dev-2022/26_try-on-gallery/features/26_r3f-web-avatar/client/node_modules/three/src/textures/Texture.js"],"names":["EventDispatcher","MirroredRepeatWrapping","ClampToEdgeWrapping","RepeatWrapping","LinearEncoding","UnsignedByteType","RGBAFormat","LinearMipmapLinearFilter","LinearFilter","UVMapping","MathUtils","Vector2","Matrix3","Source","textureId","Texture","constructor","image","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","Object","defineProperty","value","uuid","generateUUID","name","source","mipmaps","internalFormat","offset","repeat","center","rotation","matrixAutoUpdate","matrix","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","userData","version","onUpdate","isRenderTargetTexture","needsPMREMUpdate","data","updateMatrix","setUvTransform","x","y","clone","copy","slice","JSON","parse","stringify","needsUpdate","toJSON","meta","isRootObject","undefined","textures","output","metadata","generator","wrap","dispose","dispatchEvent","transformUv","uv","applyMatrix3","Math","floor","abs","ceil","prototype","isTexture"],"mappings":"AAAA,SAASA,eAAT,QAAgC,4BAAhC;AACA,SACCC,sBADD,EAECC,mBAFD,EAGCC,cAHD,EAICC,cAJD,EAKCC,gBALD,EAMCC,UAND,EAOCC,wBAPD,EAQCC,YARD,EASCC,SATD,QAUO,iBAVP;AAWA,OAAO,KAAKC,SAAZ,MAA2B,sBAA3B;AACA,SAASC,OAAT,QAAwB,oBAAxB;AACA,SAASC,OAAT,QAAwB,oBAAxB;AACA,SAASC,MAAT,QAAuB,aAAvB;AAEA,IAAIC,SAAS,GAAG,CAAhB;;AAEA,MAAMC,OAAN,SAAsBf,eAAtB,CAAsC;AAErCgB,EAAAA,WAAW,GAAwR;AAAA,QAAtRC,KAAsR,uEAA9QF,OAAO,CAACG,aAAsQ;AAAA,QAAvPC,OAAuP,uEAA7OJ,OAAO,CAACK,eAAqO;AAAA,QAApNC,KAAoN,uEAA5MnB,mBAA4M;AAAA,QAAvLoB,KAAuL,uEAA/KpB,mBAA+K;AAAA,QAA1JqB,SAA0J,uEAA9If,YAA8I;AAAA,QAAhIgB,SAAgI,uEAApHjB,wBAAoH;AAAA,QAA1FkB,MAA0F,uEAAjFnB,UAAiF;AAAA,QAArEoB,IAAqE,uEAA9DrB,gBAA8D;AAAA,QAA5CsB,UAA4C,uEAA/B,CAA+B;AAAA,QAA5BC,QAA4B,uEAAjBxB,cAAiB;AAElS;AAEAyB,IAAAA,MAAM,CAACC,cAAP,CAAuB,IAAvB,EAA6B,IAA7B,EAAmC;AAAEC,MAAAA,KAAK,EAAEjB,SAAS;AAAlB,KAAnC;AAEA,SAAKkB,IAAL,GAAYtB,SAAS,CAACuB,YAAV,EAAZ;AAEA,SAAKC,IAAL,GAAY,EAAZ;AAEA,SAAKC,MAAL,GAAc,IAAItB,MAAJ,CAAYI,KAAZ,CAAd;AACA,SAAKmB,OAAL,GAAe,EAAf;AAEA,SAAKjB,OAAL,GAAeA,OAAf;AAEA,SAAKE,KAAL,GAAaA,KAAb;AACA,SAAKC,KAAL,GAAaA,KAAb;AAEA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AAEA,SAAKG,UAAL,GAAkBA,UAAlB;AAEA,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKY,cAAL,GAAsB,IAAtB;AACA,SAAKX,IAAL,GAAYA,IAAZ;AAEA,SAAKY,MAAL,GAAc,IAAI3B,OAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAd;AACA,SAAK4B,MAAL,GAAc,IAAI5B,OAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAd;AACA,SAAK6B,MAAL,GAAc,IAAI7B,OAAJ,CAAa,CAAb,EAAgB,CAAhB,CAAd;AACA,SAAK8B,QAAL,GAAgB,CAAhB;AAEA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,MAAL,GAAc,IAAI/B,OAAJ,EAAd;AAEA,SAAKgC,eAAL,GAAuB,IAAvB;AACA,SAAKC,gBAAL,GAAwB,KAAxB;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKC,eAAL,GAAuB,CAAvB,CAtCkS,CAsCxQ;AAE1B;AACA;AACA;AACA;;AACA,SAAKnB,QAAL,GAAgBA,QAAhB;AAEA,SAAKoB,QAAL,GAAgB,EAAhB;AAEA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,QAAL,GAAgB,IAAhB;AAEA,SAAKC,qBAAL,GAA6B,KAA7B,CAnDkS,CAmD9P;;AACpC,SAAKC,gBAAL,GAAwB,KAAxB,CApDkS,CAoDnQ;AAE/B;;AAEQ,MAALnC,KAAK,GAAG;AAEX,WAAO,KAAKkB,MAAL,CAAYkB,IAAnB;AAEA;;AAEQ,MAALpC,KAAK,CAAEc,KAAF,EAAU;AAElB,SAAKI,MAAL,CAAYkB,IAAZ,GAAmBtB,KAAnB;AAEA;;AAEDuB,EAAAA,YAAY,GAAG;AAEd,SAAKX,MAAL,CAAYY,cAAZ,CAA4B,KAAKjB,MAAL,CAAYkB,CAAxC,EAA2C,KAAKlB,MAAL,CAAYmB,CAAvD,EAA0D,KAAKlB,MAAL,CAAYiB,CAAtE,EAAyE,KAAKjB,MAAL,CAAYkB,CAArF,EAAwF,KAAKhB,QAA7F,EAAuG,KAAKD,MAAL,CAAYgB,CAAnH,EAAsH,KAAKhB,MAAL,CAAYiB,CAAlI;AAEA;;AAEDC,EAAAA,KAAK,GAAG;AAEP,WAAO,IAAI,KAAK1C,WAAT,GAAuB2C,IAAvB,CAA6B,IAA7B,CAAP;AAEA;;AAEDA,EAAAA,IAAI,CAAExB,MAAF,EAAW;AAEd,SAAKD,IAAL,GAAYC,MAAM,CAACD,IAAnB;AAEA,SAAKC,MAAL,GAAcA,MAAM,CAACA,MAArB;AACA,SAAKC,OAAL,GAAeD,MAAM,CAACC,OAAP,CAAewB,KAAf,CAAsB,CAAtB,CAAf;AAEA,SAAKzC,OAAL,GAAegB,MAAM,CAAChB,OAAtB;AAEA,SAAKE,KAAL,GAAac,MAAM,CAACd,KAApB;AACA,SAAKC,KAAL,GAAaa,MAAM,CAACb,KAApB;AAEA,SAAKC,SAAL,GAAiBY,MAAM,CAACZ,SAAxB;AACA,SAAKC,SAAL,GAAiBW,MAAM,CAACX,SAAxB;AAEA,SAAKG,UAAL,GAAkBQ,MAAM,CAACR,UAAzB;AAEA,SAAKF,MAAL,GAAcU,MAAM,CAACV,MAArB;AACA,SAAKY,cAAL,GAAsBF,MAAM,CAACE,cAA7B;AACA,SAAKX,IAAL,GAAYS,MAAM,CAACT,IAAnB;AAEA,SAAKY,MAAL,CAAYqB,IAAZ,CAAkBxB,MAAM,CAACG,MAAzB;AACA,SAAKC,MAAL,CAAYoB,IAAZ,CAAkBxB,MAAM,CAACI,MAAzB;AACA,SAAKC,MAAL,CAAYmB,IAAZ,CAAkBxB,MAAM,CAACK,MAAzB;AACA,SAAKC,QAAL,GAAgBN,MAAM,CAACM,QAAvB;AAEA,SAAKC,gBAAL,GAAwBP,MAAM,CAACO,gBAA/B;AACA,SAAKC,MAAL,CAAYgB,IAAZ,CAAkBxB,MAAM,CAACQ,MAAzB;AAEA,SAAKC,eAAL,GAAuBT,MAAM,CAACS,eAA9B;AACA,SAAKC,gBAAL,GAAwBV,MAAM,CAACU,gBAA/B;AACA,SAAKC,KAAL,GAAaX,MAAM,CAACW,KAApB;AACA,SAAKC,eAAL,GAAuBZ,MAAM,CAACY,eAA9B;AACA,SAAKnB,QAAL,GAAgBO,MAAM,CAACP,QAAvB;AAEA,SAAKoB,QAAL,GAAgBa,IAAI,CAACC,KAAL,CAAYD,IAAI,CAACE,SAAL,CAAgB5B,MAAM,CAACa,QAAvB,CAAZ,CAAhB;AAEA,SAAKgB,WAAL,GAAmB,IAAnB;AAEA,WAAO,IAAP;AAEA;;AAEDC,EAAAA,MAAM,CAAEC,IAAF,EAAS;AAEd,UAAMC,YAAY,GAAKD,IAAI,KAAKE,SAAT,IAAsB,OAAOF,IAAP,KAAgB,QAA7D;;AAEA,QAAK,CAAEC,YAAF,IAAkBD,IAAI,CAACG,QAAL,CAAe,KAAKrC,IAApB,MAA+BoC,SAAtD,EAAkE;AAEjE,aAAOF,IAAI,CAACG,QAAL,CAAe,KAAKrC,IAApB,CAAP;AAEA;;AAED,UAAMsC,MAAM,GAAG;AAEdC,MAAAA,QAAQ,EAAE;AACTtB,QAAAA,OAAO,EAAE,GADA;AAETvB,QAAAA,IAAI,EAAE,SAFG;AAGT8C,QAAAA,SAAS,EAAE;AAHF,OAFI;AAQdxC,MAAAA,IAAI,EAAE,KAAKA,IARG;AASdE,MAAAA,IAAI,EAAE,KAAKA,IATG;AAWdjB,MAAAA,KAAK,EAAE,KAAKkB,MAAL,CAAY8B,MAAZ,CAAoBC,IAApB,EAA2BlC,IAXpB;AAadb,MAAAA,OAAO,EAAE,KAAKA,OAbA;AAedoB,MAAAA,MAAM,EAAE,CAAE,KAAKA,MAAL,CAAYiB,CAAd,EAAiB,KAAKjB,MAAL,CAAYkB,CAA7B,CAfM;AAgBdnB,MAAAA,MAAM,EAAE,CAAE,KAAKA,MAAL,CAAYkB,CAAd,EAAiB,KAAKlB,MAAL,CAAYmB,CAA7B,CAhBM;AAiBdjB,MAAAA,MAAM,EAAE,CAAE,KAAKA,MAAL,CAAYgB,CAAd,EAAiB,KAAKhB,MAAL,CAAYiB,CAA7B,CAjBM;AAkBdhB,MAAAA,QAAQ,EAAE,KAAKA,QAlBD;AAoBdgC,MAAAA,IAAI,EAAE,CAAE,KAAKpD,KAAP,EAAc,KAAKC,KAAnB,CApBQ;AAsBdG,MAAAA,MAAM,EAAE,KAAKA,MAtBC;AAuBdC,MAAAA,IAAI,EAAE,KAAKA,IAvBG;AAwBdE,MAAAA,QAAQ,EAAE,KAAKA,QAxBD;AA0BdJ,MAAAA,SAAS,EAAE,KAAKA,SA1BF;AA2BdD,MAAAA,SAAS,EAAE,KAAKA,SA3BF;AA4BdI,MAAAA,UAAU,EAAE,KAAKA,UA5BH;AA8BdmB,MAAAA,KAAK,EAAE,KAAKA,KA9BE;AAgCdD,MAAAA,gBAAgB,EAAE,KAAKA,gBAhCT;AAiCdE,MAAAA,eAAe,EAAE,KAAKA;AAjCR,KAAf;AAqCA,QAAKc,IAAI,CAACE,SAAL,CAAgB,KAAKf,QAArB,MAAoC,IAAzC,EAAgDsB,MAAM,CAACtB,QAAP,GAAkB,KAAKA,QAAvB;;AAEhD,QAAK,CAAEmB,YAAP,EAAsB;AAErBD,MAAAA,IAAI,CAACG,QAAL,CAAe,KAAKrC,IAApB,IAA6BsC,MAA7B;AAEA;;AAED,WAAOA,MAAP;AAEA;;AAEDI,EAAAA,OAAO,GAAG;AAET,SAAKC,aAAL,CAAoB;AAAEjD,MAAAA,IAAI,EAAE;AAAR,KAApB;AAEA;;AAEDkD,EAAAA,WAAW,CAAEC,EAAF,EAAO;AAEjB,QAAK,KAAK1D,OAAL,KAAiBV,SAAtB,EAAkC,OAAOoE,EAAP;AAElCA,IAAAA,EAAE,CAACC,YAAH,CAAiB,KAAKnC,MAAtB;;AAEA,QAAKkC,EAAE,CAACrB,CAAH,GAAO,CAAP,IAAYqB,EAAE,CAACrB,CAAH,GAAO,CAAxB,EAA4B;AAE3B,cAAS,KAAKnC,KAAd;AAEC,aAAKlB,cAAL;AAEC0E,UAAAA,EAAE,CAACrB,CAAH,GAAOqB,EAAE,CAACrB,CAAH,GAAOuB,IAAI,CAACC,KAAL,CAAYH,EAAE,CAACrB,CAAf,CAAd;AACA;;AAED,aAAKtD,mBAAL;AAEC2E,UAAAA,EAAE,CAACrB,CAAH,GAAOqB,EAAE,CAACrB,CAAH,GAAO,CAAP,GAAW,CAAX,GAAe,CAAtB;AACA;;AAED,aAAKvD,sBAAL;AAEC,cAAK8E,IAAI,CAACE,GAAL,CAAUF,IAAI,CAACC,KAAL,CAAYH,EAAE,CAACrB,CAAf,IAAqB,CAA/B,MAAuC,CAA5C,EAAgD;AAE/CqB,YAAAA,EAAE,CAACrB,CAAH,GAAOuB,IAAI,CAACG,IAAL,CAAWL,EAAE,CAACrB,CAAd,IAAoBqB,EAAE,CAACrB,CAA9B;AAEA,WAJD,MAIO;AAENqB,YAAAA,EAAE,CAACrB,CAAH,GAAOqB,EAAE,CAACrB,CAAH,GAAOuB,IAAI,CAACC,KAAL,CAAYH,EAAE,CAACrB,CAAf,CAAd;AAEA;;AAED;AAxBF;AA4BA;;AAED,QAAKqB,EAAE,CAACpB,CAAH,GAAO,CAAP,IAAYoB,EAAE,CAACpB,CAAH,GAAO,CAAxB,EAA4B;AAE3B,cAAS,KAAKnC,KAAd;AAEC,aAAKnB,cAAL;AAEC0E,UAAAA,EAAE,CAACpB,CAAH,GAAOoB,EAAE,CAACpB,CAAH,GAAOsB,IAAI,CAACC,KAAL,CAAYH,EAAE,CAACpB,CAAf,CAAd;AACA;;AAED,aAAKvD,mBAAL;AAEC2E,UAAAA,EAAE,CAACpB,CAAH,GAAOoB,EAAE,CAACpB,CAAH,GAAO,CAAP,GAAW,CAAX,GAAe,CAAtB;AACA;;AAED,aAAKxD,sBAAL;AAEC,cAAK8E,IAAI,CAACE,GAAL,CAAUF,IAAI,CAACC,KAAL,CAAYH,EAAE,CAACpB,CAAf,IAAqB,CAA/B,MAAuC,CAA5C,EAAgD;AAE/CoB,YAAAA,EAAE,CAACpB,CAAH,GAAOsB,IAAI,CAACG,IAAL,CAAWL,EAAE,CAACpB,CAAd,IAAoBoB,EAAE,CAACpB,CAA9B;AAEA,WAJD,MAIO;AAENoB,YAAAA,EAAE,CAACpB,CAAH,GAAOoB,EAAE,CAACpB,CAAH,GAAOsB,IAAI,CAACC,KAAL,CAAYH,EAAE,CAACpB,CAAf,CAAd;AAEA;;AAED;AAxBF;AA4BA;;AAED,QAAK,KAAKX,KAAV,EAAkB;AAEjB+B,MAAAA,EAAE,CAACpB,CAAH,GAAO,IAAIoB,EAAE,CAACpB,CAAd;AAEA;;AAED,WAAOoB,EAAP;AAEA;;AAEc,MAAXb,WAAW,CAAEjC,KAAF,EAAU;AAExB,QAAKA,KAAK,KAAK,IAAf,EAAsB;AAErB,WAAKkB,OAAL;AACA,WAAKd,MAAL,CAAY6B,WAAZ,GAA0B,IAA1B;AAEA;AAED;;AAvRoC;;AA2RtCjD,OAAO,CAACG,aAAR,GAAwB,IAAxB;AACAH,OAAO,CAACK,eAAR,GAA0BX,SAA1B;AAEAM,OAAO,CAACoE,SAAR,CAAkBC,SAAlB,GAA8B,IAA9B;AAEA,SAASrE,OAAT","sourcesContent":["import { EventDispatcher } from '../core/EventDispatcher.js';\nimport {\n\tMirroredRepeatWrapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tLinearEncoding,\n\tUnsignedByteType,\n\tRGBAFormat,\n\tLinearMipmapLinearFilter,\n\tLinearFilter,\n\tUVMapping\n} from '../constants.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Source } from './Source.js';\n\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype.isTexture = true;\n\nexport { Texture };\n"]},"metadata":{},"sourceType":"module"}
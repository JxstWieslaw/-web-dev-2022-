{"ast":null,"code":"import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\n\nconst col = new THREE.Color();\n\nfunction Container(_ref) {\n  let {\n    canvasSize,\n    scene,\n    index,\n    children,\n    frames,\n    rect,\n    track\n  } = _ref;\n  const get = useThree(state => state.get);\n  const camera = useThree(state => state.camera);\n  const virtualScene = useThree(state => state.scene);\n  const setEvents = useThree(state => state.setEvents);\n  let frameCount = 0;\n  useFrame(state => {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n\n      rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n\n    if (rect.current) {\n      const {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height\n      } = rect.current;\n      const isOffscreen = bottom < 0 || top > canvasSize.height || right < 0 || left > canvasSize.width;\n      const positiveYUpBottom = canvasSize.height - bottom;\n      const aspect = width / height;\n\n      if (isOrthographicCamera(camera)) {\n        if (camera.left !== width / -2 || camera.right !== width / 2 || camera.top !== height / 2 || camera.bottom !== height / -2) {\n          Object.assign(camera, {\n            left: width / -2,\n            right: width / 2,\n            top: height / 2,\n            bottom: height / -2\n          });\n          camera.updateProjectionMatrix();\n        }\n      } else if (camera.aspect !== aspect) {\n        camera.aspect = aspect;\n        camera.updateProjectionMatrix();\n      }\n\n      state.gl.setViewport(left, positiveYUpBottom, width, height);\n      state.gl.setScissor(left, positiveYUpBottom, width, height);\n      state.gl.setScissorTest(true);\n\n      if (isOffscreen) {\n        state.gl.getClearColor(col);\n        state.gl.setClearColor(col, state.gl.getClearAlpha());\n        state.gl.clear(true, true);\n        return;\n      } // When children are present render the portalled scene, otherwise the default scene\n\n\n      state.gl.render(children ? virtualScene : scene, camera);\n    }\n  }, index);\n  React.useEffect(() => {\n    // Connect the event layer to the tracking element\n    const old = get().events.connected;\n    setEvents({\n      connected: track.current\n    });\n    return () => setEvents({\n      connected: old\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nconst View = _ref2 => {\n  let {\n    track,\n    index = 1,\n    frames = Infinity,\n    children\n  } = _ref2;\n  const rect = React.useRef(null);\n  const {\n    size,\n    scene\n  } = useThree();\n  const [virtualScene] = React.useState(() => new THREE.Scene());\n  const compute = React.useCallback((event, state) => {\n    if (track.current && event.target === track.current) {\n      const {\n        width,\n        height,\n        left,\n        top\n      } = rect.current;\n      const x = event.clientX - left;\n      const y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect]);\n  const [ready, toggle] = React.useReducer(() => true, false);\n  React.useEffect(() => {\n    var _track$current2; // We need the tracking elements bounds beforehand in order to inject it into the portal\n\n\n    rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect(); // And now we can proceed\n\n    toggle();\n  }, []);\n  return ready && createPortal( /*#__PURE__*/React.createElement(Container, {\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute,\n      priority: index\n    },\n    size: {\n      width: rect.current.width,\n      height: rect.current.height\n    }\n  });\n};\n\nexport { View };","map":{"version":3,"sources":["C:/Users/pc/Documents/Repositories/web-dev-2022/26_try-on-gallery/features/26_r3f-web-avatar/client/node_modules/@react-three/drei/web/View.js"],"names":["React","THREE","useThree","createPortal","useFrame","isOrthographicCamera","def","col","Color","Container","canvasSize","scene","index","children","frames","rect","track","get","state","camera","virtualScene","setEvents","frameCount","Infinity","_track$current","current","getBoundingClientRect","left","right","top","bottom","width","height","isOffscreen","positiveYUpBottom","aspect","Object","assign","updateProjectionMatrix","gl","setViewport","setScissor","setScissorTest","getClearColor","setClearColor","getClearAlpha","clear","render","useEffect","old","events","connected","createElement","Fragment","View","useRef","size","useState","Scene","compute","useCallback","event","target","x","clientX","y","clientY","pointer","set","raycaster","setFromCamera","ready","toggle","useReducer","_track$current2","priority"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\n\nconst col = new THREE.Color();\n\nfunction Container({\n  canvasSize,\n  scene,\n  index,\n  children,\n  frames,\n  rect,\n  track\n}) {\n  const get = useThree(state => state.get);\n  const camera = useThree(state => state.camera);\n  const virtualScene = useThree(state => state.scene);\n  const setEvents = useThree(state => state.setEvents);\n  let frameCount = 0;\n  useFrame(state => {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n\n      rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n\n    if (rect.current) {\n      const {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height\n      } = rect.current;\n      const isOffscreen = bottom < 0 || top > canvasSize.height || right < 0 || left > canvasSize.width;\n      const positiveYUpBottom = canvasSize.height - bottom;\n      const aspect = width / height;\n\n      if (isOrthographicCamera(camera)) {\n        if (camera.left !== width / -2 || camera.right !== width / 2 || camera.top !== height / 2 || camera.bottom !== height / -2) {\n          Object.assign(camera, {\n            left: width / -2,\n            right: width / 2,\n            top: height / 2,\n            bottom: height / -2\n          });\n          camera.updateProjectionMatrix();\n        }\n      } else if (camera.aspect !== aspect) {\n        camera.aspect = aspect;\n        camera.updateProjectionMatrix();\n      }\n\n      state.gl.setViewport(left, positiveYUpBottom, width, height);\n      state.gl.setScissor(left, positiveYUpBottom, width, height);\n      state.gl.setScissorTest(true);\n\n      if (isOffscreen) {\n        state.gl.getClearColor(col);\n        state.gl.setClearColor(col, state.gl.getClearAlpha());\n        state.gl.clear(true, true);\n        return;\n      } // When children are present render the portalled scene, otherwise the default scene\n\n\n      state.gl.render(children ? virtualScene : scene, camera);\n    }\n  }, index);\n  React.useEffect(() => {\n    // Connect the event layer to the tracking element\n    const old = get().events.connected;\n    setEvents({\n      connected: track.current\n    });\n    return () => setEvents({\n      connected: old\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nconst View = ({\n  track,\n  index = 1,\n  frames = Infinity,\n  children\n}) => {\n  const rect = React.useRef(null);\n  const {\n    size,\n    scene\n  } = useThree();\n  const [virtualScene] = React.useState(() => new THREE.Scene());\n  const compute = React.useCallback((event, state) => {\n    if (track.current && event.target === track.current) {\n      const {\n        width,\n        height,\n        left,\n        top\n      } = rect.current;\n      const x = event.clientX - left;\n      const y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect]);\n  const [ready, toggle] = React.useReducer(() => true, false);\n  React.useEffect(() => {\n    var _track$current2;\n\n    // We need the tracking elements bounds beforehand in order to inject it into the portal\n    rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect(); // And now we can proceed\n\n    toggle();\n  }, []);\n  return ready && createPortal( /*#__PURE__*/React.createElement(Container, {\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute,\n      priority: index\n    },\n    size: {\n      width: rect.current.width,\n      height: rect.current.height\n    }\n  });\n};\n\nexport { View };\n"]},"metadata":{},"sourceType":"module"}
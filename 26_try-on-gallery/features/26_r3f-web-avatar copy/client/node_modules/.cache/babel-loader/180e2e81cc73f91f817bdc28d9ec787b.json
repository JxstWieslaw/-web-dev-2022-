{"ast":null,"code":"import { BufferAttribute, ClampToEdgeWrapping, DoubleSide, InterpolateDiscrete, InterpolateLinear, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MathUtils, Matrix4, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, PropertyBinding, RGBAFormat, RepeatWrapping, Scene, Source, Vector3 } from 'three';\n\nclass GLTFExporter {\n  constructor() {\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n  /**\r\n   * Parse scenes and generate GLTF output\r\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n   * @param  {Function} onDone  Callback on completed\r\n   * @param  {Function} onError  Callback on errors\r\n   * @param  {Object} options options\r\n   */\n\n\n  parse(input, onDone, onError, options) {\n    if (typeof onError === 'object') {\n      console.warn('THREE.GLTFExporter: parse() expects options as the fourth argument now.');\n      options = onError;\n    }\n\n    const writer = new GLTFWriter();\n    const plugins = [];\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options).catch(onError);\n  }\n\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n\n} //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942; //------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\r\n * Compare two arrays\r\n * @param  {Array} array1 Array 1 to compare\r\n * @param  {Array} array2 Array 2 to compare\r\n * @return {Boolean}        Returns true if both arrays are equal\r\n */\n\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n/**\r\n * Converts a string to an ArrayBuffer.\r\n * @param  {string} text\r\n * @return {ArrayBuffer}\r\n */\n\n\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\n/**\r\n * Is identity matrix\r\n *\r\n * @param {Matrix4} matrix\r\n * @returns {Boolean} Returns true, if parameter is identity matrix\r\n */\n\n\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\n/**\r\n * Get the min and max vectors from the given attribute\r\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\r\n * @param  {Integer} start\r\n * @param  {Integer} count\r\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\r\n */\n\n\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n      }\n\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n\n  return output;\n}\n/**\r\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n *\r\n * @param {Integer} bufferSize The size the original buffer.\r\n * @returns {Integer} new buffer size with required padding.\r\n *\r\n */\n\n\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n/**\r\n * Returns a buffer aligned to 4-byte boundary.\r\n *\r\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n * @param {Integer} paddingByte (Optional)\r\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n */\n\n\nfunction getPaddedArrayBuffer(arrayBuffer) {\n  let paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n\n    return array.buffer;\n  }\n\n  return arrayBuffer;\n}\n\nlet cachedCanvas = null;\n\nfunction getCanvas() {\n  if (cachedCanvas) {\n    return cachedCanvas;\n  }\n\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    cachedCanvas = new OffscreenCanvas(1, 1);\n  } else {\n    cachedCanvas = document.createElement('canvas');\n  }\n\n  return cachedCanvas;\n}\n/**\r\n * Writer\r\n */\n\n\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\r\n   * Parse scenes and generate GLTF output\r\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n   * @param  {Function} onDone  Callback on completed\r\n   * @param  {Object} options options\r\n   */\n\n\n  async write(input, onDone, options) {\n    this.options = Object.assign({}, {\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      truncateDrawRange: true,\n      embedImages: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n\n    this.processInput(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n    const blob = new Blob(buffers, {\n      type: 'application/octet-stream'\n    }); // Declare extensions.\n\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n\n      reader.onloadend = function () {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(reader.result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream'\n        });\n        const glbReader = new FileReader();\n        glbReader.readAsArrayBuffer(glbBlob);\n\n        glbReader.onloadend = function () {\n          onDone(glbReader.result);\n        };\n      };\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n\n        reader.onloadend = function () {\n          const base64data = reader.result;\n          json.buffers[0].uri = base64data;\n          onDone(json);\n        };\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\r\n   * Serializes a userData.\r\n   *\r\n   * @param {THREE.Object3D|THREE.Material} object\r\n   * @param {Object} objectDef\r\n   */\n\n\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n\n        delete json.gltfExtensions;\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn('THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' + 'won\\'t be serialized because of JSON.stringify error - ' + error.message);\n    }\n  }\n  /**\r\n   * Assign and return a temporal unique id for an object\r\n   * especially which doesn't have .uuid\r\n   * @param  {Object} object\r\n   * @return {Integer}\r\n   */\n\n\n  getUID(object) {\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n    return this.uids.get(object);\n  }\n  /**\r\n   * Checks if normal attribute values are normalized.\r\n   *\r\n   * @param {BufferAttribute} normal\r\n   * @returns {Boolean}\r\n   */\n\n\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n\n    return true;\n  }\n  /**\r\n   * Creates normalized normal buffer attribute.\r\n   *\r\n   * @param {BufferAttribute} normal\r\n   * @returns {BufferAttribute}\r\n   *\r\n   */\n\n\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\r\n   * Applies a texture transform, if present, to the map definition. Requires\r\n   * the KHR_texture_transform extension.\r\n   *\r\n   * @param {Object} mapDef\r\n   * @param {THREE.Texture} texture\r\n   */\n\n\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap;\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.');\n    const metalness = metalnessMap === null || metalnessMap === void 0 ? void 0 : metalnessMap.image;\n    const roughness = roughnessMap === null || roughnessMap === void 0 ? void 0 : roughnessMap.image;\n    const width = Math.max((metalness === null || metalness === void 0 ? void 0 : metalness.width) || 0, (roughness === null || roughness === void 0 ? void 0 : roughness.width) || 0);\n    const height = Math.max((metalness === null || metalness === void 0 ? void 0 : metalness.height) || 0, (roughness === null || roughness === void 0 ? void 0 : roughness.height) || 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d');\n    context.fillStyle = '#00ffff';\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const data = context.getImageData(0, 0, width, height).data;\n\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = data[i];\n      }\n    }\n\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const data = context.getImageData(0, 0, width, height).data;\n\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = data[i];\n      }\n    }\n\n    context.putImageData(composite, 0, 0); //\n\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Source(canvas);\n    return texture;\n  }\n  /**\r\n   * Process a buffer to append to the default one.\r\n   * @param  {ArrayBuffer} buffer\r\n   * @return {Integer}\r\n   */\n\n\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }]; // All buffers are merged before export.\n\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\r\n   * Process and generate a BufferView\r\n   * @param  {BufferAttribute} attribute\r\n   * @param  {number} componentType\r\n   * @param  {number} start\r\n   * @param  {number} count\r\n   * @param  {number} target (Optional) Target usage of the BufferView\r\n   * @return {Object}\r\n   */\n\n\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n\n        offset += componentSize;\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\r\n   * Process and generate a BufferView from an image Blob.\r\n   * @param {Blob} blob\r\n   * @return {Promise<Integer>}\r\n   */\n\n\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(function (resolve) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n\n      reader.onloadend = function () {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n  /**\r\n   * Process attribute to generate an accessor\r\n   * @param  {BufferAttribute} attribute Attribute to process\r\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n   * @param  {Integer} start (Optional)\r\n   * @param  {Integer} count (Optional)\r\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n   */\n\n\n  processAccessor(attribute, geometry, start, count) {\n    const options = this.options;\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4'\n    };\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n    }\n\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n      const end = start + count;\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n      start = Math.max(start, geometry.drawRange.start);\n      count = Math.min(end, end2) - start;\n      if (count < 0) count = 0;\n    } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\r\n   * Process image\r\n   * @param  {Image} image to process\r\n   * @param  {Integer} format of the image (RGBAFormat)\r\n   * @param  {Boolean} flipY before writing out the image\r\n   * @param  {String} mimeType export format\r\n   * @return {Integer}     Index of the processed texture in the \"images\" array\r\n   */\n\n\n  processImage(image, format, flipY) {\n    let mimeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'image/png';\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n    if (!cache.images.has(image)) cache.images.set(image, {});\n    const cachedImages = cache.images.get(image);\n    const key = mimeType + ':flipY/' + flipY.toString();\n    if (cachedImages[key] !== undefined) return cachedImages[key];\n    if (!json.images) json.images = [];\n    const imageDef = {\n      mimeType: mimeType\n    };\n\n    if (options.embedImages) {\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d');\n\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.');\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      }\n\n      if (options.binary === true) {\n        let toBlobPromise;\n\n        if (canvas.toBlob !== undefined) {\n          toBlobPromise = new Promise(resolve => canvas.toBlob(resolve, mimeType));\n        } else {\n          let quality; // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n          // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\n          if (mimeType === 'image/jpeg') {\n            quality = 0.92;\n          } else if (mimeType === 'image/webp') {\n            quality = 0.8;\n          }\n\n          toBlobPromise = canvas.convertToBlob({\n            type: mimeType,\n            quality: quality\n          });\n        }\n\n        pending.push(toBlobPromise.then(blob => writer.processBufferViewImage(blob).then(bufferViewIndex => {\n          imageDef.bufferView = bufferViewIndex;\n        })));\n      } else {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      }\n    } else {\n      imageDef.uri = image.src;\n    }\n\n    const index = json.images.push(imageDef) - 1;\n    cachedImages[key] = index;\n    return index;\n  }\n  /**\r\n   * Process sampler\r\n   * @param  {Texture} map Texture to process\r\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n   */\n\n\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\r\n   * Process texture\r\n   * @param  {Texture} map Map to process\r\n   * @return {Integer} Index of the processed texture in the \"textures\" array\r\n   */\n\n\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    let mimeType = map.userData.mimeType;\n    if (mimeType === 'image/webp') mimeType = 'image/png';\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name) textureDef.name = map.name;\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\r\n   * Process material\r\n   * @param  {THREE.Material} material Material to process\r\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n   */\n\n\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    } // pbrMetallicRoughness.baseColorFactor\n\n\n    const color = material.color.toArray().concat([material.opacity]);\n\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture)\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map)\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n\n    if (material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n      }\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      } // emissiveTexture\n\n\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap)\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    } // normalTexture\n\n\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap)\n      };\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    } // occlusionTexture\n\n\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1\n      };\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    } // alphaMode\n\n\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    } // doubleSided\n\n\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\r\n   * Process mesh\r\n   * @param  {THREE.Mesh} mesh Mesh to process\r\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n   */\n\n\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode; // Use the correct mode\n\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n    }\n\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    } // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n\n\n    let modifiedAttribute = null;\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n      modifiedAttribute = null;\n      const array = attribute.array;\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n\n      if (accessor !== null) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n\n            continue;\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n\n          if (cache.attributes.has(this.getUID(attribute))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n            continue;\n          } // Clones attribute not to override\n\n\n          const relativeAttribute = attribute.clone();\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n            }\n          }\n\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n        }\n\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n\n      meshDef.weights = weights;\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count;\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n\n        if (primitive.indices === null) delete primitive.indices;\n      }\n\n      const material = this.processMaterial(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\r\n   * Process camera\r\n   * @param  {THREE.Camera} camera Camera to process\r\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n   */\n\n\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } // Question: Is saving \"type\" as name intentional?\n\n\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\r\n   * Creates glTF animation entry from AnimationClip object.\r\n   *\r\n   * Status:\r\n   * - Only properties listed in PATH_PROPERTIES may be animated.\r\n   *\r\n   * @param {THREE.AnimationClip} clip\r\n   * @param {THREE.Object3D} root\r\n   * @return {number|null}\r\n   */\n\n\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\r\n   * @param {THREE.Object3D} object\r\n   * @return {number|null}\r\n   */\n\n\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === undefined) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === undefined) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n\n    if (json.skins === undefined) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\r\n   * Process Object3D node\r\n   * @param  {THREE.Object3D} node Object3D to processNode\r\n   * @return {Integer} Index of the node in the nodes list\r\n   */\n\n\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n\n    if (object.isSkinnedMesh) this.skins.push(object);\n\n    if (object.children.length > 0) {\n      const children = [];\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children;\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\r\n   * Process Scene\r\n   * @param  {Scene} node Scene to process\r\n   */\n\n\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\r\n   * Creates a Scene to hold a list of objects and parse it\r\n   * @param  {Array} objects List of objects to process\r\n   */\n\n\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n\n    this.processScene(scene);\n  }\n  /**\r\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n   */\n\n\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n\n    const objectsWithoutScene = [];\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  }\n\n}\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\n\n\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      light: lights.length - 1\n    };\n  }\n\n}\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n\n}\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\r\n */\n\n\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n\n    const specularFactor = [1, 1, 1];\n    material.specular.toArray(specularFactor, 0);\n    extensionDef.specularFactor = specularFactor;\n    extensionDef.glossinessFactor = material.glossiness;\n\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n\n    if (material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap)\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n */\n\n\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_clearcoat';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap)\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap)\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap)\n      };\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap)\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\n\n\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap)\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\r\n * Static utility functions\r\n */\n\n\nGLTFExporter.Utils = {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n\n      let mergedTrack; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n};\nexport { GLTFExporter };","map":{"version":3,"sources":["C:/Users/pc/Documents/Repositories/web-dev-2022/26_try-on-gallery/features/26_r3f-web-avatar copy/client/src/components-configurator/exporter/GLTFExporter.js"],"names":["BufferAttribute","ClampToEdgeWrapping","DoubleSide","InterpolateDiscrete","InterpolateLinear","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MathUtils","Matrix4","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","PropertyBinding","RGBAFormat","RepeatWrapping","Scene","Source","Vector3","GLTFExporter","constructor","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsClearcoatExtension","callback","indexOf","push","unregister","splice","parse","input","onDone","onError","options","console","warn","GLTFWriter","plugins","i","il","length","setPlugins","write","catch","parseAsync","scope","Promise","resolve","reject","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","value","array","getX","getY","getZ","getW","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","cachedCanvas","getCanvas","document","OffscreenCanvas","createElement","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","all","blob","Blob","type","extensionsUsedList","keys","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","undefined","extensionName","extras","error","name","message","getUID","has","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","normalize","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTexture","metalnessMap","roughnessMap","metalness","image","roughness","width","height","canvas","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","data","putImageData","reference","source","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","dataView","setFloat32","setUint16","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","processAccessor","geometry","types","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","minMax","bufferViewTarget","bufferView","accessorDef","normalized","accessors","processImage","format","flipY","mimeType","cachedImages","key","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","toBlobPromise","toBlob","quality","convertToBlob","then","bufferViewIndex","toDataURL","src","processSampler","map","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTexture","textureDef","sampler","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","slice","toUpperCase","validVertexAttributes","test","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","Utils","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex","writeNode","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","isMeshPhysicalMaterial","clearcoatFactor","clearcoat","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex"],"mappings":"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","sourcesContent":["import {\r\n\tBufferAttribute,\r\n\tClampToEdgeWrapping,\r\n\tDoubleSide,\r\n\tInterpolateDiscrete,\r\n\tInterpolateLinear,\r\n\tLinearFilter,\r\n\tLinearMipmapLinearFilter,\r\n\tLinearMipmapNearestFilter,\r\n\tMathUtils,\r\n\tMatrix4,\r\n\tMirroredRepeatWrapping,\r\n\tNearestFilter,\r\n\tNearestMipmapLinearFilter,\r\n\tNearestMipmapNearestFilter,\r\n\tPropertyBinding,\r\n\tRGBAFormat,\r\n\tRepeatWrapping,\r\n\tScene,\r\n\tSource,\r\n\tVector3\r\n} from 'three';\r\n\r\n\r\nclass GLTFExporter {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.pluginCallbacks = [];\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFLightExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsPBRSpecularGlossiness( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( writer ) {\r\n\r\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.push( callback );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tunregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Parse scenes and generate GLTF output\r\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n\t * @param  {Function} onDone  Callback on completed\r\n\t * @param  {Function} onError  Callback on errors\r\n\t * @param  {Object} options options\r\n\t */\r\n\tparse( input, onDone, onError, options ) {\r\n\r\n\t\tif ( typeof onError === 'object' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: parse() expects options as the fourth argument now.' );\r\n\r\n\t\t\toptions = onError;\r\n\r\n\t\t}\r\n\r\n\t\tconst writer = new GLTFWriter();\r\n\t\tconst plugins = [];\r\n\r\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\r\n\r\n\t\t}\r\n\r\n\t\twriter.setPlugins( plugins );\r\n\t\twriter.write( input, onDone, options ).catch( onError );\r\n\r\n\t}\r\n\r\n\tparseAsync( input, options ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tscope.parse( input, resolve, reject, options );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\nconst WEBGL_CONSTANTS = {\r\n\tPOINTS: 0x0000,\r\n\tLINES: 0x0001,\r\n\tLINE_LOOP: 0x0002,\r\n\tLINE_STRIP: 0x0003,\r\n\tTRIANGLES: 0x0004,\r\n\tTRIANGLE_STRIP: 0x0005,\r\n\tTRIANGLE_FAN: 0x0006,\r\n\r\n\tUNSIGNED_BYTE: 0x1401,\r\n\tUNSIGNED_SHORT: 0x1403,\r\n\tFLOAT: 0x1406,\r\n\tUNSIGNED_INT: 0x1405,\r\n\tARRAY_BUFFER: 0x8892,\r\n\tELEMENT_ARRAY_BUFFER: 0x8893,\r\n\r\n\tNEAREST: 0x2600,\r\n\tLINEAR: 0x2601,\r\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\r\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\r\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\r\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\r\n\r\n\tCLAMP_TO_EDGE: 33071,\r\n\tMIRRORED_REPEAT: 33648,\r\n\tREPEAT: 10497\r\n};\r\n\r\nconst THREE_TO_WEBGL = {};\r\n\r\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\r\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\r\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\r\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\r\n\r\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\r\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\r\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\r\n\r\nconst PATH_PROPERTIES = {\r\n\tscale: 'scale',\r\n\tposition: 'translation',\r\n\tquaternion: 'rotation',\r\n\tmorphTargetInfluences: 'weights'\r\n};\r\n\r\n// GLB constants\r\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\nconst GLB_HEADER_BYTES = 12;\r\nconst GLB_HEADER_MAGIC = 0x46546C67;\r\nconst GLB_VERSION = 2;\r\n\r\nconst GLB_CHUNK_PREFIX_BYTES = 8;\r\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\r\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\r\n\r\n//------------------------------------------------------------------------------\r\n// Utility functions\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Compare two arrays\r\n * @param  {Array} array1 Array 1 to compare\r\n * @param  {Array} array2 Array 2 to compare\r\n * @return {Boolean}        Returns true if both arrays are equal\r\n */\r\nfunction equalArray( array1, array2 ) {\r\n\r\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\r\n\r\n\t\treturn element === array2[ index ];\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n * Converts a string to an ArrayBuffer.\r\n * @param  {string} text\r\n * @return {ArrayBuffer}\r\n */\r\nfunction stringToArrayBuffer( text ) {\r\n\r\n\treturn new TextEncoder().encode( text ).buffer;\r\n\r\n}\r\n\r\n/**\r\n * Is identity matrix\r\n *\r\n * @param {Matrix4} matrix\r\n * @returns {Boolean} Returns true, if parameter is identity matrix\r\n */\r\nfunction isIdentityMatrix( matrix ) {\r\n\r\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\r\n\r\n}\r\n\r\n/**\r\n * Get the min and max vectors from the given attribute\r\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\r\n * @param  {Integer} start\r\n * @param  {Integer} count\r\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\r\n */\r\nfunction getMinMax( attribute, start, count ) {\r\n\r\n\tconst output = {\r\n\r\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\r\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\r\n\r\n\t};\r\n\r\n\tfor ( let i = start; i < start + count; i ++ ) {\r\n\r\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\r\n\r\n\t\t\tlet value;\r\n\r\n\t\t\tif ( attribute.itemSize > 4 ) {\r\n\r\n\t\t\t\t // no support for interleaved data for itemSize > 4\r\n\r\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\r\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\r\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\r\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\r\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn output;\r\n\r\n}\r\n\r\n/**\r\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n *\r\n * @param {Integer} bufferSize The size the original buffer.\r\n * @returns {Integer} new buffer size with required padding.\r\n *\r\n */\r\nfunction getPaddedBufferSize( bufferSize ) {\r\n\r\n\treturn Math.ceil( bufferSize / 4 ) * 4;\r\n\r\n}\r\n\r\n/**\r\n * Returns a buffer aligned to 4-byte boundary.\r\n *\r\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n * @param {Integer} paddingByte (Optional)\r\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n */\r\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\r\n\r\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\r\n\r\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\r\n\r\n\t\tconst array = new Uint8Array( paddedLength );\r\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\r\n\r\n\t\tif ( paddingByte !== 0 ) {\r\n\r\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = paddingByte;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn array.buffer;\r\n\r\n\t}\r\n\r\n\treturn arrayBuffer;\r\n\r\n}\r\n\r\nlet cachedCanvas = null;\r\n\r\nfunction getCanvas() {\r\n\r\n\tif ( cachedCanvas ) {\r\n\r\n\t\treturn cachedCanvas;\r\n\r\n\t}\r\n\r\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\r\n\r\n\t\tcachedCanvas = new OffscreenCanvas( 1, 1 );\r\n\r\n\t} else {\r\n\r\n\t\tcachedCanvas = document.createElement( 'canvas' );\r\n\r\n\t}\r\n\r\n\treturn cachedCanvas;\r\n\r\n}\r\n\r\n/**\r\n * Writer\r\n */\r\nclass GLTFWriter {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.plugins = [];\r\n\r\n\t\tthis.options = {};\r\n\t\tthis.pending = [];\r\n\t\tthis.buffers = [];\r\n\r\n\t\tthis.byteOffset = 0;\r\n\t\tthis.buffers = [];\r\n\t\tthis.nodeMap = new Map();\r\n\t\tthis.skins = [];\r\n\t\tthis.extensionsUsed = {};\r\n\r\n\t\tthis.uids = new Map();\r\n\t\tthis.uid = 0;\r\n\r\n\t\tthis.json = {\r\n\t\t\tasset: {\r\n\t\t\t\tversion: '2.0',\r\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.cache = {\r\n\t\t\tmeshes: new Map(),\r\n\t\t\tattributes: new Map(),\r\n\t\t\tattributesNormalized: new Map(),\r\n\t\t\tmaterials: new Map(),\r\n\t\t\ttextures: new Map(),\r\n\t\t\timages: new Map()\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tsetPlugins( plugins ) {\r\n\r\n\t\tthis.plugins = plugins;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Parse scenes and generate GLTF output\r\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n\t * @param  {Function} onDone  Callback on completed\r\n\t * @param  {Object} options options\r\n\t */\r\n\tasync write( input, onDone, options ) {\r\n\r\n\t\tthis.options = Object.assign( {}, {\r\n\t\t\t// default options\r\n\t\t\tbinary: false,\r\n\t\t\ttrs: false,\r\n\t\t\tonlyVisible: true,\r\n\t\t\ttruncateDrawRange: true,\r\n\t\t\tembedImages: true,\r\n\t\t\tmaxTextureSize: Infinity,\r\n\t\t\tanimations: [],\r\n\t\t\tincludeCustomExtensions: false\r\n\t\t}, options );\r\n\r\n\t\tif ( this.options.animations.length > 0 ) {\r\n\r\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\r\n\t\t\tthis.options.trs = true;\r\n\r\n\t\t}\r\n\r\n\t\tthis.processInput( input );\r\n\r\n\t\tawait Promise.all( this.pending );\r\n\r\n\t\tconst writer = this;\r\n\t\tconst buffers = writer.buffers;\r\n\t\tconst json = writer.json;\r\n\t\toptions = writer.options;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\t// Merge buffers.\r\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\r\n\r\n\t\t// Declare extensions.\r\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\r\n\r\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\r\n\r\n\t\t// Update bytelength of the single buffer.\r\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\r\n\r\n\t\tif ( options.binary === true ) {\r\n\r\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\n\t\t\tconst reader = new FileReader();\r\n\t\t\treader.readAsArrayBuffer( blob );\r\n\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\t// Binary chunk.\r\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\r\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\r\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\r\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\r\n\r\n\t\t\t\t// JSON chunk.\r\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\r\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\r\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\r\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\r\n\r\n\t\t\t\t// GLB header.\r\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\r\n\t\t\t\tconst headerView = new DataView( header );\r\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\r\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\r\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\r\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\r\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\r\n\r\n\t\t\t\tconst glbBlob = new Blob( [\r\n\t\t\t\t\theader,\r\n\t\t\t\t\tjsonChunkPrefix,\r\n\t\t\t\t\tjsonChunk,\r\n\t\t\t\t\tbinaryChunkPrefix,\r\n\t\t\t\t\tbinaryChunk\r\n\t\t\t\t], { type: 'application/octet-stream' } );\r\n\r\n\t\t\t\tconst glbReader = new FileReader();\r\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\r\n\t\t\t\tglbReader.onloadend = function () {\r\n\r\n\t\t\t\t\tonDone( glbReader.result );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\r\n\r\n\t\t\t\tconst reader = new FileReader();\r\n\t\t\t\treader.readAsDataURL( blob );\r\n\t\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\t\tconst base64data = reader.result;\r\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\r\n\t\t\t\t\tonDone( json );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tonDone( json );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Serializes a userData.\r\n\t *\r\n\t * @param {THREE.Object3D|THREE.Material} object\r\n\t * @param {Object} objectDef\r\n\t */\r\n\tserializeUserData( object, objectDef ) {\r\n\r\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\r\n\r\n\t\tconst options = this.options;\r\n\t\tconst extensionsUsed = this.extensionsUsed;\r\n\r\n\t\ttry {\r\n\r\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\r\n\r\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\r\n\r\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\r\n\r\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\r\n\r\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\r\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete json.gltfExtensions;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\r\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Assign and return a temporal unique id for an object\r\n\t * especially which doesn't have .uuid\r\n\t * @param  {Object} object\r\n\t * @return {Integer}\r\n\t */\r\n\tgetUID( object ) {\r\n\r\n\t\tif ( ! this.uids.has( object ) ) this.uids.set( object, this.uid ++ );\r\n\r\n\t\treturn this.uids.get( object );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if normal attribute values are normalized.\r\n\t *\r\n\t * @param {BufferAttribute} normal\r\n\t * @returns {Boolean}\r\n\t */\r\n\tisNormalizedNormalAttribute( normal ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\r\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\r\n\r\n\t\tconst v = new Vector3();\r\n\r\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\r\n\r\n\t\t\t// 0.0005 is from glTF-validator\r\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates normalized normal buffer attribute.\r\n\t *\r\n\t * @param {BufferAttribute} normal\r\n\t * @returns {BufferAttribute}\r\n\t *\r\n\t */\r\n\tcreateNormalizedNormalAttribute( normal ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\r\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\r\n\r\n\t\tconst attribute = normal.clone();\r\n\t\tconst v = new Vector3();\r\n\r\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\r\n\r\n\t\t\tv.fromBufferAttribute( attribute, i );\r\n\r\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\r\n\r\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\r\n\t\t\t\tv.setX( 1.0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv.normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\r\n\r\n\t\t}\r\n\r\n\t\tcache.attributesNormalized.set( normal, attribute );\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a texture transform, if present, to the map definition. Requires\r\n\t * the KHR_texture_transform extension.\r\n\t *\r\n\t * @param {Object} mapDef\r\n\t * @param {THREE.Texture} texture\r\n\t */\r\n\tapplyTextureTransform( mapDef, texture ) {\r\n\r\n\t\tlet didTransform = false;\r\n\t\tconst transformDef = {};\r\n\r\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\r\n\r\n\t\t\ttransformDef.offset = texture.offset.toArray();\r\n\t\t\tdidTransform = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.rotation !== 0 ) {\r\n\r\n\t\t\ttransformDef.rotation = texture.rotation;\r\n\t\t\tdidTransform = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\r\n\r\n\t\t\ttransformDef.scale = texture.repeat.toArray();\r\n\t\t\tdidTransform = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( didTransform ) {\r\n\r\n\t\t\tmapDef.extensions = mapDef.extensions || {};\r\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\r\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbuildMetalRoughTexture( metalnessMap, roughnessMap ) {\r\n\r\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\r\n\r\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\r\n\r\n\t\tconst metalness = metalnessMap?.image;\r\n\t\tconst roughness = roughnessMap?.image;\r\n\r\n\t\tconst width = Math.max( metalness?.width || 0, roughness?.width || 0 );\r\n\t\tconst height = Math.max( metalness?.height || 0, roughness?.height || 0 );\r\n\r\n\t\tconst canvas = getCanvas();\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tconst context = canvas.getContext( '2d' );\r\n\t\tcontext.fillStyle = '#00ffff';\r\n\t\tcontext.fillRect( 0, 0, width, height );\r\n\r\n\t\tconst composite = context.getImageData( 0, 0, width, height );\r\n\r\n\t\tif ( metalness ) {\r\n\r\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\r\n\r\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\r\n\r\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\r\n\r\n\t\t\t\tcomposite.data[ i ] = data[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( roughness ) {\r\n\r\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\r\n\r\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\r\n\r\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\r\n\r\n\t\t\t\tcomposite.data[ i ] = data[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( composite, 0, 0 );\r\n\r\n\t\t//\r\n\r\n\t\tconst reference = metalnessMap || roughnessMap;\r\n\r\n\t\tconst texture = reference.clone();\r\n\r\n\t\ttexture.source = new Source( canvas );\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process a buffer to append to the default one.\r\n\t * @param  {ArrayBuffer} buffer\r\n\t * @return {Integer}\r\n\t */\r\n\tprocessBuffer( buffer ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst buffers = this.buffers;\r\n\r\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\r\n\r\n\t\t// All buffers are merged before export.\r\n\t\tbuffers.push( buffer );\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process and generate a BufferView\r\n\t * @param  {BufferAttribute} attribute\r\n\t * @param  {number} componentType\r\n\t * @param  {number} start\r\n\t * @param  {number} count\r\n\t * @param  {number} target (Optional) Target usage of the BufferView\r\n\t * @return {Object}\r\n\t */\r\n\tprocessBufferView( attribute, componentType, start, count, target ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\r\n\r\n\t\t// Create a new dataview and dump the attribute's array into it\r\n\r\n\t\tlet componentSize;\r\n\r\n\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\r\n\r\n\t\t\tcomponentSize = 1;\r\n\r\n\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\r\n\r\n\t\t\tcomponentSize = 2;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcomponentSize = 4;\r\n\r\n\t\t}\r\n\r\n\t\tconst byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\r\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\r\n\t\tlet offset = 0;\r\n\r\n\t\tfor ( let i = start; i < start + count; i ++ ) {\r\n\r\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\r\n\r\n\t\t\t\tlet value;\r\n\r\n\t\t\t\tif ( attribute.itemSize > 4 ) {\r\n\r\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\r\n\r\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\r\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\r\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\r\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\r\n\r\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\r\n\r\n\t\t\t\t\tdataView.setUint32( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\r\n\r\n\t\t\t\t\tdataView.setUint16( offset, value, true );\r\n\r\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\r\n\r\n\t\t\t\t\tdataView.setUint8( offset, value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\toffset += componentSize;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst bufferViewDef = {\r\n\r\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\r\n\t\t\tbyteOffset: this.byteOffset,\r\n\t\t\tbyteLength: byteLength\r\n\r\n\t\t};\r\n\r\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\r\n\r\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\r\n\r\n\t\t\t// Only define byteStride for vertex attributes.\r\n\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\r\n\r\n\t\t}\r\n\r\n\t\tthis.byteOffset += byteLength;\r\n\r\n\t\tjson.bufferViews.push( bufferViewDef );\r\n\r\n\t\t// @TODO Merge bufferViews where possible.\r\n\t\tconst output = {\r\n\r\n\t\t\tid: json.bufferViews.length - 1,\r\n\t\t\tbyteLength: 0\r\n\r\n\t\t};\r\n\r\n\t\treturn output;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process and generate a BufferView from an image Blob.\r\n\t * @param {Blob} blob\r\n\t * @return {Promise<Integer>}\r\n\t */\r\n\tprocessBufferViewImage( blob ) {\r\n\r\n\t\tconst writer = this;\r\n\t\tconst json = writer.json;\r\n\r\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\r\n\r\n\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\tconst reader = new FileReader();\r\n\t\t\treader.readAsArrayBuffer( blob );\r\n\t\t\treader.onloadend = function () {\r\n\r\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\r\n\r\n\t\t\t\tconst bufferViewDef = {\r\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\r\n\t\t\t\t\tbyteOffset: writer.byteOffset,\r\n\t\t\t\t\tbyteLength: buffer.byteLength\r\n\t\t\t\t};\r\n\r\n\t\t\t\twriter.byteOffset += buffer.byteLength;\r\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\r\n\r\n\t\t\t};\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process attribute to generate an accessor\r\n\t * @param  {BufferAttribute} attribute Attribute to process\r\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n\t * @param  {Integer} start (Optional)\r\n\t * @param  {Integer} count (Optional)\r\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n\t */\r\n\tprocessAccessor( attribute, geometry, start, count ) {\r\n\r\n\t\tconst options = this.options;\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst types = {\r\n\r\n\t\t\t1: 'SCALAR',\r\n\t\t\t2: 'VEC2',\r\n\t\t\t3: 'VEC3',\r\n\t\t\t4: 'VEC4',\r\n\t\t\t16: 'MAT4'\r\n\r\n\t\t};\r\n\r\n\t\tlet componentType;\r\n\r\n\t\t// Detect the component type of the attribute array (float, uint or ushort)\r\n\t\tif ( attribute.array.constructor === Float32Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\r\n\r\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\r\n\r\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( start === undefined ) start = 0;\r\n\t\tif ( count === undefined ) count = attribute.count;\r\n\r\n\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\r\n\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\r\n\r\n\t\t\tconst end = start + count;\r\n\t\t\tconst end2 = geometry.drawRange.count === Infinity\r\n\t\t\t\t? attribute.count\r\n\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\r\n\r\n\t\t\tstart = Math.max( start, geometry.drawRange.start );\r\n\t\t\tcount = Math.min( end, end2 ) - start;\r\n\r\n\t\t\tif ( count < 0 ) count = 0;\r\n\r\n\t\t}\r\n\r\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\r\n\t\tif ( count === 0 ) return null;\r\n\r\n\t\tconst minMax = getMinMax( attribute, start, count );\r\n\t\tlet bufferViewTarget;\r\n\r\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\r\n\t\t// animation samplers, target must not be set.\r\n\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\r\n\r\n\t\t}\r\n\r\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\r\n\r\n\t\tconst accessorDef = {\r\n\r\n\t\t\tbufferView: bufferView.id,\r\n\t\t\tbyteOffset: bufferView.byteOffset,\r\n\t\t\tcomponentType: componentType,\r\n\t\t\tcount: count,\r\n\t\t\tmax: minMax.max,\r\n\t\t\tmin: minMax.min,\r\n\t\t\ttype: types[ attribute.itemSize ]\r\n\r\n\t\t};\r\n\r\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\r\n\t\tif ( ! json.accessors ) json.accessors = [];\r\n\r\n\t\treturn json.accessors.push( accessorDef ) - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process image\r\n\t * @param  {Image} image to process\r\n\t * @param  {Integer} format of the image (RGBAFormat)\r\n\t * @param  {Boolean} flipY before writing out the image\r\n\t * @param  {String} mimeType export format\r\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\r\n\t */\r\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\r\n\r\n\t\tconst writer = this;\r\n\t\tconst cache = writer.cache;\r\n\t\tconst json = writer.json;\r\n\t\tconst options = writer.options;\r\n\t\tconst pending = writer.pending;\r\n\r\n\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\r\n\r\n\t\tconst cachedImages = cache.images.get( image );\r\n\r\n\t\tconst key = mimeType + ':flipY/' + flipY.toString();\r\n\r\n\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\r\n\r\n\t\tif ( ! json.images ) json.images = [];\r\n\r\n\t\tconst imageDef = { mimeType: mimeType };\r\n\r\n\t\tif ( options.embedImages ) {\r\n\r\n\t\t\tconst canvas = getCanvas();\r\n\r\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\r\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\r\n\r\n\t\t\tconst ctx = canvas.getContext( '2d' );\r\n\r\n\t\t\tif ( flipY === true ) {\r\n\r\n\t\t\t\tctx.translate( 0, canvas.height );\r\n\t\t\t\tctx.scale( 1, - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\r\n\r\n\t\t\t\tif ( format !== RGBAFormat ) {\r\n\r\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\r\n\r\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\r\n\r\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\r\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\r\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\r\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( options.binary === true ) {\r\n\r\n\t\t\t\tlet toBlobPromise;\r\n\r\n\t\t\t\tif ( canvas.toBlob !== undefined ) {\r\n\r\n\t\t\t\t\ttoBlobPromise = new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tlet quality;\r\n\r\n\t\t\t\t\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\r\n\t\t\t\t\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\r\n\t\t\t\t\tif ( mimeType === 'image/jpeg' ) {\r\n\r\n\t\t\t\t\t\tquality = 0.92;\r\n\r\n\t\t\t\t\t} else if ( mimeType === 'image/webp' ) {\r\n\r\n\t\t\t\t\t\tquality = 0.8;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttoBlobPromise = canvas.convertToBlob( {\r\n\r\n\t\t\t\t\t\ttype: mimeType,\r\n\t\t\t\t\t\tquality: quality\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpending.push( toBlobPromise.then( blob =>\r\n\r\n\t\t\t\t\twriter.processBufferViewImage( blob ).then( bufferViewIndex => {\r\n\r\n\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\r\n\r\n\t\t\t\t\t} )\r\n\r\n\t\t\t\t) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\timageDef.uri = image.src;\r\n\r\n\t\t}\r\n\r\n\t\tconst index = json.images.push( imageDef ) - 1;\r\n\t\tcachedImages[ key ] = index;\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process sampler\r\n\t * @param  {Texture} map Texture to process\r\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n\t */\r\n\tprocessSampler( map ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( ! json.samplers ) json.samplers = [];\r\n\r\n\t\tconst samplerDef = {\r\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\r\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\r\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\r\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\r\n\t\t};\r\n\r\n\t\treturn json.samplers.push( samplerDef ) - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process texture\r\n\t * @param  {Texture} map Map to process\r\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\r\n\t */\r\n\tprocessTexture( map ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\r\n\r\n\t\tif ( ! json.textures ) json.textures = [];\r\n\r\n\t\tlet mimeType = map.userData.mimeType;\r\n\r\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\r\n\r\n\t\tconst textureDef = {\r\n\t\t\tsampler: this.processSampler( map ),\r\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\r\n\t\t};\r\n\r\n\t\tif ( map.name ) textureDef.name = map.name;\r\n\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst index = json.textures.push( textureDef ) - 1;\r\n\t\tcache.textures.set( map, index );\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process material\r\n\t * @param  {THREE.Material} material Material to process\r\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n\t */\r\n\tprocessMaterial( material ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\r\n\r\n\t\tif ( material.isShaderMaterial ) {\r\n\r\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! json.materials ) json.materials = [];\r\n\r\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\r\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\r\n\r\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\r\n\r\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\r\n\r\n\t\t}\r\n\r\n\t\t// pbrMetallicRoughness.baseColorFactor\r\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\r\n\r\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\r\n\r\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.isMeshStandardMaterial ) {\r\n\r\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\r\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\r\n\r\n\t\t}\r\n\r\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\r\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\r\n\r\n\t\t\tconst metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );\r\n\r\n\t\t\tconst metalRoughMapDef = { index: this.processTexture( metalRoughTexture ) };\r\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\r\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\r\n\r\n\t\t}\r\n\r\n\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tconst baseColorMapDef = { index: this.processTexture( material.map ) };\r\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\r\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissive ) {\r\n\r\n\t\t\t// note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\r\n\t\t\tconst emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity );\r\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\r\n\r\n\t\t\tif ( maxEmissiveComponent > 1 ) {\r\n\r\n\t\t\t\temissive.multiplyScalar( 1 / maxEmissiveComponent );\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( maxEmissiveComponent > 0 ) {\r\n\r\n\t\t\t\tmaterialDef.emissiveFactor = emissive.toArray();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// emissiveTexture\r\n\t\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\t\tconst emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };\r\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\r\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// normalTexture\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tconst normalMapDef = { index: this.processTexture( material.normalMap ) };\r\n\r\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\r\n\r\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\r\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\r\n\t\t\tmaterialDef.normalTexture = normalMapDef;\r\n\r\n\t\t}\r\n\r\n\t\t// occlusionTexture\r\n\t\tif ( material.aoMap ) {\r\n\r\n\t\t\tconst occlusionMapDef = {\r\n\t\t\t\tindex: this.processTexture( material.aoMap ),\r\n\t\t\t\ttexCoord: 1\r\n\t\t\t};\r\n\r\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\r\n\r\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\r\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\r\n\r\n\t\t}\r\n\r\n\t\t// alphaMode\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tmaterialDef.alphaMode = 'BLEND';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( material.alphaTest > 0.0 ) {\r\n\r\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\r\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// doubleSided\r\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\r\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\r\n\r\n\t\tthis.serializeUserData( material, materialDef );\r\n\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst index = json.materials.push( materialDef ) - 1;\r\n\t\tcache.materials.set( material, index );\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process mesh\r\n\t * @param  {THREE.Mesh} mesh Mesh to process\r\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n\t */\r\n\tprocessMesh( mesh ) {\r\n\r\n\t\tconst cache = this.cache;\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\r\n\r\n\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\r\n\r\n\t\t}\r\n\r\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\r\n\r\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tlet mode;\r\n\r\n\t\t// Use the correct mode\r\n\t\tif ( mesh.isLineSegments ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\r\n\r\n\t\t} else if ( mesh.isLineLoop ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\r\n\r\n\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\r\n\r\n\t\t} else if ( mesh.isPoints ) {\r\n\r\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.isBufferGeometry !== true ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst meshDef = {};\r\n\t\tconst attributes = {};\r\n\t\tconst primitives = [];\r\n\t\tconst targets = [];\r\n\r\n\t\t// Conversion between attributes names in threejs and gltf spec\r\n\t\tconst nameConversion = {\r\n\t\t\tuv: 'TEXCOORD_0',\r\n\t\t\tuv2: 'TEXCOORD_1',\r\n\t\t\tcolor: 'COLOR_0',\r\n\t\t\tskinWeight: 'WEIGHTS_0',\r\n\t\t\tskinIndex: 'JOINTS_0'\r\n\t\t};\r\n\r\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\r\n\r\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\r\n\r\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\r\n\r\n\t\t}\r\n\r\n\t\t// @QUESTION Detect if .vertexColors = true?\r\n\t\t// For every attribute create an accessor\r\n\t\tlet modifiedAttribute = null;\r\n\r\n\t\tfor ( let attributeName in geometry.attributes ) {\r\n\r\n\t\t\t// Ignore morph target attributes, which are exported later.\r\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\r\n\r\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\r\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\r\n\r\n\t\t\t// Prefix all geometry attributes except the ones specifically\r\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\r\n\t\t\tconst validVertexAttributes =\r\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\r\n\r\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\r\n\r\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\r\n\r\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\r\n\t\t\tmodifiedAttribute = null;\r\n\t\t\tconst array = attribute.array;\r\n\r\n\t\t\tif ( attributeName === 'JOINTS_0' &&\r\n\t\t\t\t! ( array instanceof Uint16Array ) &&\r\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\r\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\r\n\r\n\t\t\tif ( accessor !== null ) {\r\n\r\n\t\t\t\tattributes[ attributeName ] = accessor;\r\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\r\n\r\n\t\t// Skip if no exportable attributes found\r\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\r\n\r\n\t\t// Morph targets\r\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\r\n\r\n\t\t\tconst weights = [];\r\n\t\t\tconst targetNames = [];\r\n\t\t\tconst reverseDictionary = {};\r\n\r\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\r\n\r\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\r\n\r\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\r\n\r\n\t\t\t\tconst target = {};\r\n\t\t\t\tlet warned = false;\r\n\r\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\r\n\r\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\r\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\r\n\r\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\r\n\r\n\t\t\t\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\r\n\t\t\t\t\t\t\twarned = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\r\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\r\n\r\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// glTF 2.0 Specification:\r\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\r\n\r\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\r\n\r\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\r\n\r\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute ) );\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Clones attribute not to override\r\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\r\n\r\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(\r\n\t\t\t\t\t\t\t\tj,\r\n\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\r\n\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\r\n\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\r\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute ), target[ gltfAttributeName ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargets.push( target );\r\n\r\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\r\n\r\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmeshDef.weights = weights;\r\n\r\n\t\t\tif ( targetNames.length > 0 ) {\r\n\r\n\t\t\t\tmeshDef.extras = {};\r\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\r\n\r\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\r\n\r\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\r\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\r\n\r\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst primitive = {\r\n\t\t\t\tmode: mode,\r\n\t\t\t\tattributes: attributes,\r\n\t\t\t};\r\n\r\n\t\t\tthis.serializeUserData( geometry, primitive );\r\n\r\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\r\n\r\n\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\r\n\r\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\r\n\r\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\r\n\r\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\r\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\r\n\r\n\t\t\tif ( material !== null ) primitive.material = material;\r\n\r\n\t\t\tprimitives.push( primitive );\r\n\r\n\t\t}\r\n\r\n\t\tmeshDef.primitives = primitives;\r\n\r\n\t\tif ( ! json.meshes ) json.meshes = [];\r\n\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst index = json.meshes.push( meshDef ) - 1;\r\n\t\tcache.meshes.set( meshCacheKey, index );\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process camera\r\n\t * @param  {THREE.Camera} camera Camera to process\r\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n\t */\r\n\tprocessCamera( camera ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tif ( ! json.cameras ) json.cameras = [];\r\n\r\n\t\tconst isOrtho = camera.isOrthographicCamera;\r\n\r\n\t\tconst cameraDef = {\r\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\r\n\t\t};\r\n\r\n\t\tif ( isOrtho ) {\r\n\r\n\t\t\tcameraDef.orthographic = {\r\n\t\t\t\txmag: camera.right * 2,\r\n\t\t\t\tymag: camera.top * 2,\r\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\r\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcameraDef.perspective = {\r\n\t\t\t\taspectRatio: camera.aspect,\r\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\r\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\r\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// Question: Is saving \"type\" as name intentional?\r\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\r\n\r\n\t\treturn json.cameras.push( cameraDef ) - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates glTF animation entry from AnimationClip object.\r\n\t *\r\n\t * Status:\r\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\r\n\t *\r\n\t * @param {THREE.AnimationClip} clip\r\n\t * @param {THREE.Object3D} root\r\n\t * @return {number|null}\r\n\t */\r\n\tprocessAnimation( clip, root ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst nodeMap = this.nodeMap;\r\n\r\n\t\tif ( ! json.animations ) json.animations = [];\r\n\r\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\r\n\r\n\t\tconst tracks = clip.tracks;\r\n\t\tconst channels = [];\r\n\t\tconst samplers = [];\r\n\r\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\r\n\r\n\t\t\tconst track = tracks[ i ];\r\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\r\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\r\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\r\n\r\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\r\n\r\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\r\n\r\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttrackNode = undefined;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! trackNode || ! trackProperty ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst inputItemSize = 1;\r\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\r\n\r\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\r\n\r\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet interpolation;\r\n\r\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\r\n\r\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\r\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\r\n\t\t\t// valid value from .getInterpolation().\r\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\r\n\r\n\t\t\t\tinterpolation = 'CUBICSPLINE';\r\n\r\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\r\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\r\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\r\n\t\t\t\toutputItemSize /= 3;\r\n\r\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\r\n\r\n\t\t\t\tinterpolation = 'STEP';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tinterpolation = 'LINEAR';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsamplers.push( {\r\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\r\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\r\n\t\t\t\tinterpolation: interpolation\r\n\t\t\t} );\r\n\r\n\t\t\tchannels.push( {\r\n\t\t\t\tsampler: samplers.length - 1,\r\n\t\t\t\ttarget: {\r\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\r\n\t\t\t\t\tpath: trackProperty\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tjson.animations.push( {\r\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\r\n\t\t\tsamplers: samplers,\r\n\t\t\tchannels: channels\r\n\t\t} );\r\n\r\n\t\treturn json.animations.length - 1;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.Object3D} object\r\n\t * @return {number|null}\r\n\t */\r\n\t processSkin( object ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst nodeMap = this.nodeMap;\r\n\r\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\r\n\r\n\t\tconst skeleton = object.skeleton;\r\n\r\n\t\tif ( skeleton === undefined ) return null;\r\n\r\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\r\n\r\n\t\tif ( rootJoint === undefined ) return null;\r\n\r\n\t\tconst joints = [];\r\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\r\n\t\tconst temporaryBoneInverse = new Matrix4();\r\n\r\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\r\n\r\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\r\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\r\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skins === undefined ) json.skins = [];\r\n\r\n\t\tjson.skins.push( {\r\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\r\n\t\t\tjoints: joints,\r\n\t\t\tskeleton: nodeMap.get( rootJoint )\r\n\t\t} );\r\n\r\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\r\n\r\n\t\treturn skinIndex;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process Object3D node\r\n\t * @param  {THREE.Object3D} node Object3D to processNode\r\n\t * @return {Integer} Index of the node in the nodes list\r\n\t */\r\n\tprocessNode( object ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\t\tconst nodeMap = this.nodeMap;\r\n\r\n\t\tif ( ! json.nodes ) json.nodes = [];\r\n\r\n\t\tconst nodeDef = {};\r\n\r\n\t\tif ( options.trs ) {\r\n\r\n\t\t\tconst rotation = object.quaternion.toArray();\r\n\t\t\tconst position = object.position.toArray();\r\n\t\t\tconst scale = object.scale.toArray();\r\n\r\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\r\n\r\n\t\t\t\tnodeDef.rotation = rotation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\r\n\r\n\t\t\t\tnodeDef.translation = position;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\r\n\r\n\t\t\t\tnodeDef.scale = scale;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.matrixAutoUpdate ) {\r\n\r\n\t\t\t\tobject.updateMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\r\n\r\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\r\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\r\n\r\n\t\tthis.serializeUserData( object, nodeDef );\r\n\r\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\r\n\r\n\t\t\tconst meshIndex = this.processMesh( object );\r\n\r\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\r\n\r\n\t\t} else if ( object.isCamera ) {\r\n\r\n\t\t\tnodeDef.camera = this.processCamera( object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\r\n\r\n\t\tif ( object.children.length > 0 ) {\r\n\r\n\t\t\tconst children = [];\r\n\r\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst child = object.children[ i ];\r\n\r\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\r\n\r\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\r\n\r\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\r\n\r\n\t\t}\r\n\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\r\n\r\n\t\t} );\r\n\r\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\r\n\t\tnodeMap.set( object, nodeIndex );\r\n\t\treturn nodeIndex;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Process Scene\r\n\t * @param  {Scene} node Scene to process\r\n\t */\r\n\tprocessScene( scene ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\r\n\t\tif ( ! json.scenes ) {\r\n\r\n\t\t\tjson.scenes = [];\r\n\t\t\tjson.scene = 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst sceneDef = {};\r\n\r\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\r\n\r\n\t\tjson.scenes.push( sceneDef );\r\n\r\n\t\tconst nodes = [];\r\n\r\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst child = scene.children[ i ];\r\n\r\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\r\n\r\n\t\t\t\tconst nodeIndex = this.processNode( child );\r\n\r\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\r\n\r\n\t\tthis.serializeUserData( scene, sceneDef );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a Scene to hold a list of objects and parse it\r\n\t * @param  {Array} objects List of objects to process\r\n\t */\r\n\tprocessObjects( objects ) {\r\n\r\n\t\tconst scene = new Scene();\r\n\t\tscene.name = 'AuxScene';\r\n\r\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\r\n\r\n\t\t\t// We push directly to children instead of calling `add` to prevent\r\n\t\t\t// modify the .parent and break its original scene and hierarchy\r\n\t\t\tscene.children.push( objects[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.processScene( scene );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n\t */\r\n\tprocessInput( input ) {\r\n\r\n\t\tconst options = this.options;\r\n\r\n\t\tinput = input instanceof Array ? input : [ input ];\r\n\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\text.beforeParse && ext.beforeParse( input );\r\n\r\n\t\t} );\r\n\r\n\t\tconst objectsWithoutScene = [];\r\n\r\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\r\n\r\n\t\t\tif ( input[ i ] instanceof Scene ) {\r\n\r\n\t\t\t\tthis.processScene( input[ i ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\r\n\r\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\r\n\r\n\t\t\tthis.processSkin( this.skins[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\r\n\r\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\text.afterParse && ext.afterParse( input );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_invokeAll( func ) {\r\n\r\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\r\n\r\n\t\t\tfunc( this.plugins[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\nclass GLTFLightExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_lights_punctual';\r\n\r\n\t}\r\n\r\n\twriteNode( light, nodeDef ) {\r\n\r\n\t\tif ( ! light.isLight ) return;\r\n\r\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst json = writer.json;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst lightDef = {};\r\n\r\n\t\tif ( light.name ) lightDef.name = light.name;\r\n\r\n\t\tlightDef.color = light.color.toArray();\r\n\r\n\t\tlightDef.intensity = light.intensity;\r\n\r\n\t\tif ( light.isDirectionalLight ) {\r\n\r\n\t\t\tlightDef.type = 'directional';\r\n\r\n\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\tlightDef.type = 'point';\r\n\r\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\r\n\r\n\t\t} else if ( light.isSpotLight ) {\r\n\r\n\t\t\tlightDef.type = 'spot';\r\n\r\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\r\n\r\n\t\t\tlightDef.spot = {};\r\n\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\r\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\r\n\r\n\t\t}\r\n\r\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\r\n\t\t\t\t+ 'and expects light.decay=2.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( light.target\r\n\t\t\t\t&& ( light.target.parent !== light\r\n\t\t\t\t|| light.target.position.x !== 0\r\n\t\t\t\t|| light.target.position.y !== 0\r\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\r\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! extensionsUsed[ this.name ] ) {\r\n\r\n\t\t\tjson.extensions = json.extensions || {};\r\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\r\n\t\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t\t}\r\n\r\n\t\tconst lights = json.extensions[ this.name ].lights;\r\n\t\tlights.push( lightDef );\r\n\r\n\t\tnodeDef.extensions = nodeDef.extensions || {};\r\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\nclass GLTFMaterialsUnlitExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_unlit';\r\n\r\n\t}\r\n\r\n\twriteMaterial( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshBasicMaterial ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = {};\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\r\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\r\n */\r\nclass GLTFMaterialsPBRSpecularGlossiness {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_pbrSpecularGlossiness';\r\n\r\n\t}\r\n\r\n\twriteMaterial( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isGLTFSpecularGlossinessMaterial ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorFactor ) {\r\n\r\n\t\t\textensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\r\n\r\n\t\t}\r\n\r\n\t\tconst specularFactor = [ 1, 1, 1 ];\r\n\t\tmaterial.specular.toArray( specularFactor, 0 );\r\n\t\textensionDef.specularFactor = specularFactor;\r\n\t\textensionDef.glossinessFactor = material.glossiness;\r\n\r\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorTexture ) {\r\n\r\n\t\t\textensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.specularMap ) {\r\n\r\n\t\t\tconst specularMapDef = { index: writer.processTexture( material.specularMap ) };\r\n\t\t\twriter.applyTextureTransform( specularMapDef, material.specularMap );\r\n\t\t\textensionDef.specularGlossinessTexture = specularMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n */\r\nclass GLTFMaterialsClearcoatExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_clearcoat';\r\n\r\n\t}\r\n\r\n\twriteMaterial( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.clearcoatFactor = material.clearcoat;\r\n\r\n\t\tif ( material.clearcoatMap ) {\r\n\r\n\t\t\tconst clearcoatMapDef = { index: writer.processTexture( material.clearcoatMap ) };\r\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\r\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\r\n\r\n\t\tif ( material.clearcoatRoughnessMap ) {\r\n\r\n\t\t\tconst clearcoatRoughnessMapDef = { index: writer.processTexture( material.clearcoatRoughnessMap ) };\r\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\r\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.clearcoatNormalMap ) {\r\n\r\n\t\t\tconst clearcoatNormalMapDef = { index: writer.processTexture( material.clearcoatNormalMap ) };\r\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\r\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n */\r\nclass GLTFMaterialsTransmissionExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_transmission';\r\n\r\n\t}\r\n\r\n\twriteMaterial( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.transmissionFactor = material.transmission;\r\n\r\n\t\tif ( material.transmissionMap ) {\r\n\r\n\t\t\tconst transmissionMapDef = { index: writer.processTexture( material.transmissionMap ) };\r\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\r\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\r\n\r\n\t\t}\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\r\nclass GLTFMaterialsVolumeExtension {\r\n\r\n\tconstructor( writer ) {\r\n\r\n\t\tthis.writer = writer;\r\n\t\tthis.name = 'KHR_materials_volume';\r\n\r\n\t}\r\n\r\n\twriteMaterial( material, materialDef ) {\r\n\r\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\r\n\r\n\t\tconst writer = this.writer;\r\n\t\tconst extensionsUsed = writer.extensionsUsed;\r\n\r\n\t\tconst extensionDef = {};\r\n\r\n\t\textensionDef.thicknessFactor = material.thickness;\r\n\r\n\t\tif ( material.thicknessMap ) {\r\n\r\n\t\t\tconst thicknessMapDef = { index: writer.processTexture( material.thicknessMap ) };\r\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\r\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\r\n\r\n\t\t}\r\n\r\n\t\textensionDef.attenuationDistance = material.attenuationDistance;\r\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\r\n\r\n\t\tmaterialDef.extensions = materialDef.extensions || {};\r\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\r\n\r\n\t\textensionsUsed[ this.name ] = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Static utility functions\r\n */\r\nGLTFExporter.Utils = {\r\n\r\n\tinsertKeyframe: function ( track, time ) {\r\n\r\n\t\tconst tolerance = 0.001; // 1ms\r\n\t\tconst valueSize = track.getValueSize();\r\n\r\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\r\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\r\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\r\n\r\n\t\tlet index;\r\n\r\n\t\tif ( track.times.length === 0 ) {\r\n\r\n\t\t\ttimes[ 0 ] = time;\r\n\r\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\r\n\r\n\t\t\t\tvalues[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t} else if ( time < track.times[ 0 ] ) {\r\n\r\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\r\n\r\n\t\t\ttimes[ 0 ] = time;\r\n\t\t\ttimes.set( track.times, 1 );\r\n\r\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\r\n\t\t\tvalues.set( track.values, valueSize );\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\r\n\r\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\r\n\r\n\t\t\t\treturn track.times.length - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttimes[ times.length - 1 ] = time;\r\n\t\t\ttimes.set( track.times, 0 );\r\n\r\n\t\t\tvalues.set( track.values, 0 );\r\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\r\n\r\n\t\t\tindex = times.length - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\r\n\r\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\r\n\r\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\r\n\r\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\r\n\t\t\t\t\ttimes[ i + 1 ] = time;\r\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\r\n\r\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\r\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\r\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\r\n\r\n\t\t\t\t\tindex = i + 1;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ttrack.times = times;\r\n\t\ttrack.values = values;\r\n\r\n\t\treturn index;\r\n\r\n\t},\r\n\r\n\tmergeMorphTargetTracks: function ( clip, root ) {\r\n\r\n\t\tconst tracks = [];\r\n\t\tconst mergedTracks = {};\r\n\t\tconst sourceTracks = clip.tracks;\r\n\r\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\r\n\r\n\t\t\tlet sourceTrack = sourceTracks[ i ];\r\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\r\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\r\n\r\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\r\n\r\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\r\n\t\t\t\ttracks.push( sourceTrack );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\r\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\r\n\r\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\r\n\r\n\t\t\t\t\t// This should never happen, because glTF morph target animations\r\n\t\t\t\t\t// affect all targets already.\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\r\n\r\n\t\t\t\tsourceTrack = sourceTrack.clone();\r\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\r\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\r\n\r\n\t\t\tif ( targetIndex === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet mergedTrack;\r\n\r\n\t\t\t// If this is the first time we've seen this object, create a new\r\n\t\t\t// track to store merged keyframe data for each morph target.\r\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmergedTrack = sourceTrack.clone();\r\n\r\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\r\n\r\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\r\n\r\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// We need to take into consideration the intended target node\r\n\t\t\t\t// of our original un-merged morphTarget animation.\r\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\r\n\t\t\t\tmergedTrack.values = values;\r\n\r\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\r\n\t\t\t\ttracks.push( mergedTrack );\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\r\n\r\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\r\n\r\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\r\n\t\t\t// interpolated) value from the source track.\r\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\r\n\r\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// For every existing keyframe of the source track, write a (possibly\r\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\r\n\t\t\t// be written again, but keyframes are de-duplicated.\r\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\r\n\r\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\r\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tclip.tracks = tracks;\r\n\r\n\t\treturn clip;\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport { GLTFExporter };"]},"metadata":{},"sourceType":"module"}